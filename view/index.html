<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>AEGIS</title>
    <link rel="stylesheet" href="styles.css">

    <!-- <script src="https://cdn.jsdelivr.net/npm/vue@3.5.13/dist/vue.global.prod.js"></script> -->
    <script src="vue.global.prod.js"></script>
    <style>
        html {
            /* background-color: blue; */
            background-color: #2d327d;
            color: #eeeeee;
            font-size: 42px;
            /* font-size: 16px; */
            font-family: "helvetica", "sans-serif";
            font-weight: bold;
        }

        table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            margin-bottom: 15px;

            /* border: 2px solid red; */
            padding: 2px;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 0.3rem;
        }

        th {
            text-align: left;
        }

        tr {
            //height: 3rem;
            border-bottom: 1px solid white;
        }
        tr td {
            padding-top: 6px;
            padding-bottom: 6px;
//            white-space: nowrap;
        }

        thead tr,
        tr:nth-child(2n+2) {
            background-color: #4d529d;
        }

        th:nth-child(1), td:nth-child(1) {
            min-width: 30px; max-width: 30px;
        }

        th:nth-child(2), td:nth-child(2) {
            min-width: 7rem; max-width: 7rem;
        }

        th:nth-child(3), td:nth-child(3) {
            min-width: 0.5rem; max-width: 0.5rem;
        }

        th:nth-child(4), td:nth-child(4) {
            width: auto;
            color: red;
            //min-width: 10rem; //max-width: 10rem;
        }

        th:nth-child(5), td:nth-child(5) {
            min-width: 0.5rem; max-width: 0.5rem;
        }

        th:nth-child(6), td:nth-child(6) {
            min-width: 2.8rem; max-width: 2.8rem;
            font-size: 0.8rem;
        }

        td:nth-child(1) div {
            background-color: white;
            color: black;
            font-size: 0.8rem;

            padding-left: 1px;
            padding-top: 1px;
            margin-right: 10px;
        }

        td:nth-child(4), th:nth-child(6), td:nth-child(6) {
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        td:nth-child(6) {
            color: yellow;
        }

        .timer {
            float: right;
            margin-right: 15px;
        }

        html,
        body,
        body>div,
        body>div>div {
            margin: 0;
            height: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        #main {
            padding: 10px;
        }

        .danger {
            border: 4px solid orange;
        }

        .hidden {
            display: none !important;
        }

        #infobox {
            position: absolute;
            right: 0;
            background-color: rgba(255, 255, 255, 0.2);

            border: 2px solid red;
            border-radius: 20px;

            font-size: 22px;

            padding: 10px 20px;
            margin-right: 20px;

            display: grid;
            gap: 50px;
            grid-template-columns: auto auto auto;
        }

        #infobox>div {
            display: grid;
            grid-template: auto auto / auto auto;
            column-gap: 10px;
        }

        .infobox_spacing {
            margin-top: 30px;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="main" :class="{ danger: !this.connected }">

            <div id="infobox" :class="{ hidden: !this.infoConnected }">
                <div>
                    <span>Estimed sleep :</span><span></span>
                    <span id="info-sleep">14:05</span><span></span>
                </div>
                <div>
                    <span>Temp int :</span>
                    <span id="info-int-temp">-1.0°C</span>
                    <span>Humid int :</span>
                    <span id="info-int-humid">-1.0 %</span>
                </div>
                <div>
                    <span>Temp ext :</span>
                    <span id="info-ext-temp">-1.0°C</span>
                    <span>Humid ext :</span>
                    <span id="info-ext-humid">-1.0 %</span>
                </div>
            </div>

            <div v-if="!Object.keys(tables).length" class="loader" style="margin: 38vh auto; width: 15vh; height: 15vh">
            </div>

            <div v-for="(table, tableIndex) in orderedTables" :key="tableIndex" :class="{ infobox_spacing: this.infoConnected }">
                <h2>Table {{ table.table_name }}</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Heure</th>
                            <th>Dir</th>
                            <th>Destination</th>
                            <th>Voie</th>
                            <th>Remarque</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="(train, trainIndex) in table.trains" :key="trainIndex">
                            <td>
                                <div>{{ train.category }} {{ train.number }}</div>
                            </td>
                            <td><time-component :time="train.start.time" :pronotime="train.start.prono_time" /></td>
                            <td>{{ train.dir }}</td>
                            <td>{{ train.to }}</td>
                            <td style="text-align: center;">{{ train.start.platform ?? '-' }}</td>
                            <td>{{ this.formatRemark(train) }}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        const parseTime = (input) => {
            const date = new Date(input);
            return new Intl.DateTimeFormat(
                'en-GB',
                { hour: '2-digit', minute: '2-digit' }
            ).format(date);
        };
        const diffTime = (time, now = null) => {
            now = now === null ? new Date() : now;
            const timeDifference = time - now;

            const minutesUntil = Math.floor(timeDifference / (1000 * 60));

            return `${minutesUntil}'`;
        };

        Vue.createApp({
            components: {
                'time-component': {
                    props: ['time', 'pronotime'],
                    computed: {
                        templateToUse() {
                            if (this.pronotime !== undefined && this.pronotime !== null && this.time !== this.pronotime) {
                                return [
                                    `<del style="font-size: 0.5rem;">${parseTime(this.time)}</del>`,
                                    `<span style="color: yellow;">${parseTime(this.pronotime)}</span>`,
                                    `<span style="color: yellow;" class="timer" data-time='${this.pronotime}''> ${diffTime(new Date(this.pronotime))}</span>`
                                ].join('');
                            }
                            else {
                                return [
                                    `<span>${parseTime(this.time)}</span>`,
                                    `<span class="timer" data-time='${this.time}''> ${diffTime(new Date(this.time))}</span>`
                                ].join('');
                            }
                        }
                    },
                    template: `
                        <span v-html="templateToUse"></span>
                    `
                }
            },
            data() {
                return {
                    connected: false,
                    infoConnected: false,
                    tables: {}
                };
            },
            computed: {
                orderedTables: function () {
                    return Object.values(this.tables).sort((a, b) => {
                        return a.corder - b.corder
                    });
                }
            },
            methods: {
                
                pluralize(number, singular = "", plural = "s") {
                    return (number == 1 ? singular : plural);
                },
                formatRemark(train) {
                    str = [];
                    if (train.start.delay > 0) {
                        str.push(`${train.start.delay} ${this.pluralize(train.start.delay, 'minute', 'minutes')}`);
                    }
                    if (train.start.prono_platform != null && train.start.platform != train.start.prono_platform) {
                        str.push(`platform ${train.start.prono_platform}`);
                    }
                    return str.join(", ");
                },

                tryConnect(timeout = 1000) {
                    //this.connection = new WebSocket("//localhost:8765");
                    this.connection = new WebSocket(`//${window.location.hostname}:8765`);

                    this.connection.onmessage = (event) => {
                        try {
                            this.onData(JSON.parse(event.data));
                        }
                        catch (error) {
                            if (error instanceof SyntaxError) {
                                console.error("Failed to parse main JSON:", error.message);
                            }
                            else {
                                throw error;
                            }
                        }
                    }

                    this.connection.onopen = (event) => {
                        this.connected = true;
                        console.log("Successfully connected to the main websocket server...");
                        this.connection.send(JSON.stringify({ "COMMAND": "SUBSCRIBE" }));
                    }

                    this.connection.onclose = (event) => {
                        this.connected = false;
                        console.log('main onclose triggered, retry in', timeout)
                        setTimeout(() => {
                            this.tryConnect(Math.min(timeout * 3, 10 * 60 * 1000));
                        }, timeout);
                    }
                },

                tryConnectInfo(timeout = 1000) {
                    //this.infoConnect = new WebSocket("//localhost:8766");
                    this.infoConnect = new WebSocket(`//${window.location.hostname}:8766`);

                    this.infoConnect.onmessage = (event) => {
                        try {
                            this.onDataInfo(JSON.parse(event.data));
                        }
                        catch (error) {
                            if (error instanceof SyntaxError) {
                                console.error("Failed to parse infobox JSON:", error.message);
                            }
                            else {
                                throw error;
                            }
                        }
                    }

                    this.infoConnect.onopen = (event) => {
                        this.infoConnected = true;
                        console.log("Successfully connected to the infobox websocket server...");
                        this.infoConnect.send(JSON.stringify({ "COMMAND": "SUBSCRIBE" }));
                    }

                    this.infoConnect.onclose = (event) => {
                        this.infoConnected = false;
                        console.log('infobox onclose triggered, retry in', timeout)
                        setTimeout(() => {
                            this.tryConnectInfo(Math.min(timeout * 3, 10 * 60 * 1000));
                        }, timeout);
                    }
                },
                onData(data) {
                    try {
                        console.log('new trains', data["elems"]);

                        if (!Object.keys(this.tables).includes(data["id"])) {
                            this.tables[data["id"]] = {
                                table_name: data["name"],
                                corder: data["corder"],
                                trains: [],
                            }
                        }
                        this.tables[data["id"]]["trains"] = data["elems"];
                    }
                    catch (error) {
                        console.error("Error fetching table data:", error);
                    }
                },
                onDataInfo(data) {
                    try {
                        console.log('new infos', data);

                        typ = data["type"];

                        if (typ == "TEMP") {
                            if (data.hasOwnProperty("temperature-int")) { document.getElementById("info-int-temp").textContent = `${data["temperature-int"]}°C`; }
                            if (data.hasOwnProperty("humidity-int")) { document.getElementById("info-int-humid").textContent = `${data["humidity-int"]} %`; }
                            if (data.hasOwnProperty("temperature-ext")) { document.getElementById("info-ext-temp").textContent = `${data["temperature-ext"]}°C`; }
                            if (data.hasOwnProperty("humidity-ext")) { document.getElementById("info-ext-humid").textContent = `${data["humidity-ext"]} %`; }
                        }
                        else if (typ == "SLEEP") {
                            document.getElementById("info-sleep").textContent = `${data["timer"]}`;
                        }
                        else {
                            console.error("Unknown infobox type", error);
                        }
                    }
                    catch (error) {
                        console.error("Error fetching infobox data:", error);
                    }
                }
            },
            created() {
                this.tryConnect();
                this.tryConnectInfo();

                window.addEventListener('beforeunload', () => {
                    this.connection.close();
                    this.infoConnect.close();
                });

                setInterval(() => {
                    const timers = document.getElementsByClassName("timer");
                    const now = new Date();

                    for (let i = 0; i < timers.length; i++) {
                        const timerDeadline = timers[i].attributes["data-time"].value;
                        timers[i].textContent = diffTime(new Date(timerDeadline), now);
                    }
                }, 10000)
            }
        }).mount('#app');
    </script>
</body>

</html>
